<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>FIX Client — Quote / Index / Deposit (No Wallet Extension)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0b0f14; --fg: #e9eef4; --muted: #9aa7b1; --card: #121823;
      --accent: #6dd3fb; --good: #57d199; --bad: #ff6b6b; --border: #202838;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    }
    * { box-sizing: border-box; }
    body { margin: 0; color: var(--fg); background: linear-gradient(180deg, #0b0f14, #0e131a); font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial; }
    header { padding: 20px 24px; border-bottom: 1px solid var(--border); background: #0d1218; }
    h1 { margin: 0; font-size: 18px; font-weight: 600; letter-spacing: .2px; }
    main { padding: 18px 24px 40px; display: grid; grid-template-columns: 1.2fr .8fr; gap: 16px; align-items: start; }
    @media (max-width: 1100px) { main { grid-template-columns: 1fr; } }
    .card { background: var(--card); border: 1px solid var(--border); border-radius: 12px; box-shadow: 0 6px 24px rgba(0,0,0,.25); }
    .card > .hd { padding: 12px 14px; border-bottom: 1px solid var(--border); display: flex; align-items: center; justify-content: space-between; }
    .card > .bd { padding: 14px; }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    label { color: var(--muted); font-size: 12px; margin-right: 6px; }
    input, select, button, textarea { font: inherit; color: var(--fg); background: #0f141d; border: 1px solid var(--border); border-radius: 8px; padding: 8px 10px; }
    input, select { height: 34px; }
    select { cursor: pointer; }
    button { cursor: pointer; background: #131b27; transition: .15s ease; }
    button:hover { transform: translateY(-1px); border-color: #2a3852; }
    button.primary { background: linear-gradient(180deg, #18243b, #131b27); border-color: #2a3852; }
    button.good { border-color: #224738; }
    button.bad { border-color: #50303a; }
    .muted { color: var(--muted); font-size: 12px; }
    textarea { width: 100%; min-height: 220px; resize: vertical; font: 12.5px/1.45 var(--mono); background: #0c121a; }
    pre.log { height: 280px; overflow: auto; background: #0a1017; padding: 12px; border-radius: 8px; border: 1px solid var(--border); white-space: pre-wrap; }
    code { font-family: var(--mono); background: #0f141d; padding: 2px 6px; border-radius: 6px; border: 1px solid var(--border); }
    .pill { padding: 3px 8px; border-radius: 999px; font-size: 11px; border: 1px solid var(--border); background: #0f141d; color: var(--muted); }
    .flex-end { margin-left: auto; }
  </style>
</head>
<body>
  <header>
    <h1>FIX Client — Quote / Index / Deposit</h1>
  </header>

  <main>
    <!-- Controls -->
    <section class="card">
      <div class="hd">
        <div class="row">
          <label>Mode</label>
          <select id="mode">
            <option value="quote">Quote (no signature)</option>
            <option value="index">Index (requires signature)</option>
            <option value="deposit">Deposit (local signer)</option>
          </select>
          <span class="pill" id="statusBadge">idle</span>
        </div>
        <div class="row">
          <button id="formatBtn" title="Format JSON">Format JSON</button>
        </div>
      </div>

      <div class="bd">
        <div class="row" id="wsRow">
          <label>FIX WS</label>
          <input id="wsUrl" size="40" value="ws://127.0.0.1:3000/ws" />
          <button id="connectBtn" class="primary">Connect</button>
          <button id="disconnectBtn" disabled>Disconnect</button>
        </div>

        <div class="row" id="rpcRow" style="margin-top:8px;">
          <label>Anvil RPC</label>
          <input id="rpcUrl" size="40" value="http://127.0.0.1:8545" />
          <label>Contract</label>
          <input id="contractAddress" size="42" value="0xYourDepositEmitterAddress" />
        </div>

        <div id="privateKeySection" style="margin-top:8px;">
          <div class="row">
            <label>Index Private Key</label>
            <input id="indexPk" size="80" value="0xa71e5a7b07c4c0d1678679d37cd5dfb02f80750eb2e4450bdb5357f712f8421e" />
          </div>
          <div class="muted" style="margin-top:4px;">Used only for <b>Index</b> mode to sign FIX payloads (secp256k1).</div>
        </div>

        <div style="margin-top:12px;">
          <div class="row">
            <h3 style="margin:0;">Request JSON</h3>
            <span class="muted">— Deposit expects only <code>chain_id</code>, <code>address</code>, <code>amount</code></span>
          </div>
          <textarea id="payload"></textarea>
          <div class="row" style="margin-top:8px;">
            <button id="sendBtn" class="primary">Send Message</button>
            <span class="muted" id="helperNote" style="margin-left:8px; display:none;">
              Deposit calls <code>deposit(uint256,address,uint256)</code> on your contract using a local dev signer (no extension).
            </span>
            <span class="flex-end muted" id="rpcInfo"></span>
          </div>
        </div>
      </div>
    </section>

    <!-- Log -->
    <section class="card">
      <div class="hd">
        <div>Log</div>
        <div class="row">
          <button id="clearLogBtn">Clear Log</button>
        </div>
      </div>
      <div class="bd">
        <pre id="log" class="log"></pre>
      </div>
    </section>
  </main>

  <script type="module">

    import {
      JsonRpcProvider, Wallet, Contract, isHexString
    } from "https://esm.sh/ethers@6.13.0";
    import * as secp from "https://esm.sh/@noble/secp256k1@1.7.1";
    import { sha256 } from "https://esm.sh/@noble/hashes@1.3.3/sha256";
    import { hmac } from "https://esm.sh/@noble/hashes@1.3.3/hmac";
    import { toUtf8Bytes } from "https://esm.sh/ethers@6.13.0";
    secp.utils.hmacSha256Sync = (key, msg) => hmac(sha256, key, msg);


    const DEV_DEPOSIT_SIGNER_PK =
      "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80"; // Anvil acct(0)
    const CONTRACT_ABI = [
      "function deposit(uint256 chainId, address account, uint256 amount) external",
      "event Deposit(address indexed account, uint256 chainId, uint256 amount)"
    ];

    const $ = (id) => document.getElementById(id);
    const logEl = $("log");
    const statusBadge = $("statusBadge");
    function log(msg, kind = "info") {
      const ts = new Date().toISOString();
      const line = `[${ts}] ${msg}\n`;
      logEl.textContent += line;
      logEl.scrollTop = logEl.scrollHeight;
      if (kind === "good") statusBadge.textContent = "ok";
      if (kind === "bad") statusBadge.textContent = "error";
      if (kind === "info") statusBadge.textContent = "idle";
    }
    function setModeUI(mode) {
      // Index-only private key
      $("privateKeySection").style.display = mode === "index" ? "block" : "none";
      // Deposit-only RPC & contract inputs
      $("rpcRow").style.display = mode === "deposit" ? "flex" : "none";
      // WS row always visible
      $("wsRow").style.display = "flex";
      // Button text / helper note
      $("sendBtn").textContent = mode === "deposit" ? "Deposit" : "Send Message";
      $("helperNote").style.display = mode === "deposit" ? "inline" : "none";

      // Prefill JSON
      const now = new Date().toISOString();
      const sampleAddr = "0x70997970C51812dc3A010C7d01b50e0d17dc79C8";
      const json =
        mode === "deposit" ? ({
          chain_id: 42161,
          address: sampleAddr,
          amount: "1000000" // raw units (6 decimals), i.e. 1.000000
        }) :
        mode === "index" ? ({
          standard_header: {
            msg_type: "NewIndexOrder",
            sender_comp_id: "CLIENT",
            target_comp_id: "SERVER",
            seq_num: 1,
            timestamp: now,
          },
          chain_id: 1,
          address: sampleAddr,
          client_order_id: "Q-" + Date.now(),
          symbol: "SY100",
          side: "1",
          amount: "1000",
        }) : ({
          standard_header: {
            msg_type: "NewQuoteRequest",
            sender_comp_id: "CLIENT",
            target_comp_id: "SERVER",
            seq_num: 1,
            timestamp: now,
          },
          chain_id: 1,
          address: sampleAddr,
          client_quote_id: "Q-" + Date.now(),
          symbol: "SY100",
          side: "1",
          amount: "1000",
        });
      $("payload").value = JSON.stringify(json, null, 2);
    }


    const isHexAddress = (s) => /^0x[0-9a-fA-F]{40}$/.test(String(s).trim());
    function parseChainId(x) {
      if (typeof x === "number") return x;
      const s = String(x).trim();
      if (s.startsWith("0x") || s.startsWith("0X")) return parseInt(s, 16);
      return Number(s);
    }
    // "123" -> 123n ; "1.5" -> 1500000n (6 decimals); "0x..." -> BigInt hex
    function parseAmount(amount, decimals = 6) {
      const s = String(amount).trim();
      if (/^0x[0-9a-fA-F]+$/.test(s)) return BigInt(s);
      if (/^\d+$/.test(s)) return BigInt(s);
      const m = s.match(/^(\d+)\.(\d+)$/);
      if (m) {
        const [, i, f] = m;
        const fp = (f + "0".repeat(decimals)).slice(0, decimals);
        return BigInt(i + fp);
      }
      throw new Error("Invalid amount format");
    }

    let ws = null;
    $("connectBtn").onclick = () => {
      const url = $("wsUrl").value;
      ws = new WebSocket(url);
      ws.onopen = () => { log("WebSocket connected", "good"); $("connectBtn").disabled = true; $("disconnectBtn").disabled = false; };
      ws.onclose = () => { log("WebSocket disconnected"); $("connectBtn").disabled = false; $("disconnectBtn").disabled = true; };
      ws.onerror  = () => { log("WebSocket error", "bad"); };
      ws.onmessage = (e) => {
        try {
          const msg = JSON.parse(e.data);
          log("Received:\n" + JSON.stringify(msg, null, 2));
          const msgType = msg.standard_header?.msg_type;
          if (!msgType) return;
          if (msgType.includes("Quote") || msgType === "Deposit") return; // skip signature verify

          // signature verify for index messages with trailer
          const tr = msg.standard_trailer;
          if (tr?.signature && tr?.public_key) {
            const signatureHex = tr.signature[0];
            const pubKeyHex = tr.public_key[0];
            const signPayload = (() => {
              const { msg_type } = msg.standard_header;
              if (msg_type === "ACK" || msg_type === "NAK") return null;
              if (msg_type === "NewIndexOrder" || msg_type === "CancelIndexOrder")
                return { msg_type, id: msg.client_order_id };
              if (msg_type === "NewQuoteRequest" || msg_type === "CancelQuoteRequest")
                return { msg_type, id: msg.client_quote_id };
              return null;
            })();
            if (!signPayload) return;
            const hash = sha256(toUtf8Bytes(JSON.stringify(signPayload)));
            const sigBytes = secp.utils.hexToBytes(signatureHex.slice(2));
            const pubKeyBytes = secp.utils.hexToBytes(pubKeyHex.slice(2));
            const ok = secp.verify(sigBytes, hash, pubKeyBytes);
            log(ok ? "✅ Signature verified" : "❌ Signature verification failed", ok ? "good" : "bad");
          }
        } catch {
          log("Received (raw): " + e.data);
        }
      };
    };
    $("disconnectBtn").onclick = () => { try { ws?.close(); } catch {} };

    async function doDeposit(payload) {
      const rpc = $("rpcUrl").value.trim() || "http://127.0.0.1:8545";
      const contractAddr = $("contractAddress").value.trim();

      if (!isHexString(contractAddr, 20)) { log("Invalid contract address. Set a proper 0x… value.", "bad"); return; }
      let chainId, account, amount;
      try {
        chainId = parseChainId(payload.chain_id);
        account = String(payload.address || "").trim();
        amount  = parseAmount(payload.amount, 6);
      } catch (e) {
        log("Deposit payload invalid: " + e.message, "bad"); return;
      }
      if (!(Number.isFinite(chainId) && chainId > 0)) { log("Invalid chain_id", "bad"); return; }
      if (!isHexAddress(account)) { log("Invalid address", "bad"); return; }

      const provider = new JsonRpcProvider(rpc);
      // quick ping to RPC
      try { const bn = await provider.getBlockNumber(); $("rpcInfo").textContent = `RPC ok · block ${bn}`; }
      catch { log("Cannot reach RPC at " + rpc, "bad"); return; }

      const signer = new Wallet(DEV_DEPOSIT_SIGNER_PK, provider);
      const contract = new Contract(contractAddr, CONTRACT_ABI, signer);

      log(`(Deposit) RPC=${rpc}, signer=${await signer.getAddress()}`);
      log(`Calling deposit(chainId=${chainId}, account=${account}, amount=${amount.toString()}) …`);
      try {
        const tx = await contract.deposit(chainId, account, amount);
        log(`Tx sent: ${tx.hash}`);
        const r = await tx.wait();
        log(`Tx confirmed in block ${r.blockNumber}`, "good");

        // Try parsing Deposit event
        try {
          const iface = contract.interface;
          for (const lg of r.logs) {
            try {
              const parsed = iface.parseLog(lg);
              if (parsed?.name === "Deposit") {
                const { account: evAcc, chainId: evCid, amount: evAmt } = parsed.args;
                log(`Deposit event: account=${evAcc}, chainId=${evCid}, amount=${evAmt.toString()}`);
              }
            } catch {}
          }
        } catch {}
      } catch (e) {
        log("Deposit failed: " + (e?.shortMessage || e?.message || e), "bad");
      }
    }
    async function doIndex(rawText) {
      if (!ws || ws.readyState !== 1) { log("WebSocket not connected", "bad"); return; }
      const pkVal = $("indexPk").value.trim();
      const privateKeyHex = pkVal.startsWith("0x") ? pkVal.slice(2) : pkVal;
      if (!privateKeyHex) { log("Index private key required", "bad"); return; }

      const msgObj = JSON.parse(rawText);
      const bodyForSign = JSON.parse(JSON.stringify(msgObj));
      delete bodyForSign.standard_trailer;

      function minimalSignPayload(m) {
        const t = m.standard_header?.msg_type;
        if (t === "NewIndexOrder" || t === "CancelIndexOrder") return { msg_type: t, id: m.client_order_id };
        if (t === "NewQuoteRequest" || t === "CancelQuoteRequest") return { msg_type: t, id: m.client_quote_id };
        throw new Error("Unsupported msg_type");
      }
      const signPayload = minimalSignPayload(bodyForSign);
      const hash = sha256(toUtf8Bytes(JSON.stringify(signPayload)));
      const key = secp.utils.hexToBytes(privateKeyHex);
      const sig = secp.signSync(hash, key, { canonical: true, der: false });
      const signatureHex = "0x" + secp.utils.bytesToHex(sig.slice(0, 64));
      const pubKey = secp.getPublicKey(key, false);
      const pubKeyHex = "0x" + secp.utils.bytesToHex(pubKey);

      msgObj.standard_trailer = { public_key: [pubKeyHex], signature: [signatureHex] };
      const jsonString = JSON.stringify(msgObj);
      log("Sending (Index):\n" + JSON.stringify(msgObj, null, 2));
      ws.send(jsonString);
    }
    function doQuote(rawText) {
      if (!ws || ws.readyState !== 1) { log("WebSocket not connected", "bad"); return; }
      const msgObj = JSON.parse(rawText);
      delete msgObj.standard_trailer;
      const jsonString = JSON.stringify(msgObj);
      log("Sending (Quote):\n" + JSON.stringify(msgObj, null, 2));
      ws.send(jsonString);
    }

    /**********************
     * UI Wiring
     **********************/
    $("mode").onchange = () => setModeUI($("mode").value);
    $("formatBtn").onclick = () => {
      try {
        const v = JSON.parse($("payload").value || "{}");
        $("payload").value = JSON.stringify(v, null, 2);
        log("JSON formatted", "good");
      } catch (e) { log("Invalid JSON: " + e.message, "bad"); }
    };
    $("clearLogBtn").onclick = () => { logEl.textContent = ""; statusBadge.textContent = "idle"; };

    $("sendBtn").onclick = async () => {
      try {
        const mode = $("mode").value;
        const raw = $("payload").value.trim();
        if (!raw) return log("JSON is empty", "bad");

        if (mode === "deposit") {
          const obj = JSON.parse(raw);
          await doDeposit(obj);
          return;
        }
        if (mode === "index") return doIndex(raw);
        if (mode === "quote") return doQuote(raw);
      } catch (e) { log("Error: " + (e?.message || e), "bad"); }
    };

    // Initial UI
    setModeUI("deposit");
  </script>
</body>
</html>
